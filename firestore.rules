rules_version = '2';
service cloud.firestore {
  match /databases/{database}/documents {
    function isSignedIn() {
      return request.auth != null;
    }

    function isSiteAdmin() {
      let userPath = /databases/$(database)/documents/users/$(request.auth.uid);
      return isSignedIn() && exists(userPath) && get(userPath).data.role == 'siteadmin';
    }

    function isUserAdminOfGroup(uid, groupId) {
      let groupPath = /databases/$(database)/documents/groups/$(groupId);
      let memberPath = /databases/$(database)/documents/groups/$(groupId)/members/$(uid);
      return exists(groupPath) && (
        get(groupPath).data.ownerId == uid ||
        (exists(memberPath) && get(memberPath).data.isAdmin == true)
      );
    }

    function isGroupOwner(groupId) {
      let groupPath = /databases/$(database)/documents/groups/$(groupId);
      return isSignedIn() && exists(groupPath) && get(groupPath).data.ownerId == request.auth.uid;
    }

    function isGroupAdmin(groupId) {
      return isSignedIn() && (
        isSiteAdmin() ||
        isUserAdminOfGroup(request.auth.uid, groupId)
      );
    }

    function hasPendingInvite(groupId, uid) {
      let invitePath = /databases/$(database)/documents/groups/$(groupId)/invites/$(uid);
      return exists(invitePath) && get(invitePath).data.status == 'pending';
    }

    // 1. User documents
    match /users/{userId} {
      allow read: if isSignedIn();
      
      // Global siteadmin role is FORBIDDEN from client side
      // Allow role only if it's the default "user" (to let initial profile creation succeed).
      allow create: if isSignedIn() && request.auth.uid == userId && (
                    !('role' in request.resource.data) || request.resource.data.role == 'user');
      
      allow update: if isSignedIn() && (
        // Self-update: cannot touch role (except adding default role if it was missing)
        (request.auth.uid == userId && (
          !request.resource.data.diff(resource.data).affectedKeys().hasAny(['role']) ||
          (!('role' in resource.data) && request.resource.data.role == 'user')
        )) ||
        // Site Admin: can update anything
        isSiteAdmin() ||
        // Group Admin update: can update elo/formFactor if they prove shared membership
        (
          request.resource.data.diff(resource.data).affectedKeys().hasOnly(['elo', 'formFactor', 'lastGroupId']) &&
          'lastGroupId' in request.resource.data &&
          isGroupAdmin(request.resource.data.lastGroupId) &&
          exists(/databases/$(database)/documents/groups/$(request.resource.data.lastGroupId)/members/$(userId))
        )
      );

      // User group summaries
      match /groups/{groupId} {
        allow read, write: if isSignedIn() && request.auth.uid == userId;
      }

      // User notifications
      match /notifications/{notificationId} {
        allow read, update, delete: if isSignedIn() && request.auth.uid == userId;
        
        allow create: if isSignedIn() && (
          isSiteAdmin() ||
          (
            request.resource.data.get('groupId', '') is string &&
            request.resource.data.get('type', '') is string &&
            (
              request.resource.data.get('actorId', '') is string &&
              request.resource.data.actorId == request.auth.uid
            ) &&
            (
              // Case 1: Teammates (Both must be members of the group)
              (exists(/databases/$(database)/documents/groups/$(request.resource.data.groupId)/members/$(request.auth.uid)) &&
               exists(/databases/$(database)/documents/groups/$(request.resource.data.groupId)/members/$(userId))) ||
              
              // Case 2: Join Request or Membership Change (User notifying Group Admins/Owner)
              (request.resource.data.type == 'group_join' && 
               isUserAdminOfGroup(userId, request.resource.data.groupId) &&
               (exists(/databases/$(database)/documents/groups/$(request.resource.data.groupId)/joinRequests/$(request.auth.uid)) ||
                exists(/databases/$(database)/documents/groups/$(request.resource.data.groupId)/members/$(request.auth.uid)))) ||
              
              // Case 3: Joined/Rejected Decision or Admin Action
              (isGroupAdmin(request.resource.data.groupId) && 
               (exists(/databases/$(database)/documents/groups/$(request.resource.data.groupId)/members/$(userId)) ||
                exists(/databases/$(database)/documents/groups/$(request.resource.data.groupId)/joinRequests/$(userId))))
              ||
              // Case 4: Group Invite or Invite Response (scoped to existing invite)
              (
                (request.resource.data.type == 'group_invite' &&
                 isGroupAdmin(request.resource.data.groupId) &&
                 exists(/databases/$(database)/documents/groups/$(request.resource.data.groupId)/invites/$(userId)))
                ||
                (request.resource.data.type == 'group_invite_response' &&
                 exists(/databases/$(database)/documents/groups/$(request.resource.data.groupId)/invites/$(request.auth.uid)) &&
                 get(/databases/$(database)/documents/groups/$(request.resource.data.groupId)/invites/$(request.auth.uid)).data.inviterId == userId)
              )
            )
          )
        );
      }
    }

    // 1b. Contact messages (site admin only)
    match /contactMessages/{messageId} {
      allow read, update, delete: if isSiteAdmin();
      allow create: if isSignedIn();
    }

    match /contactMessages_Archived/{messageId} {
      allow read, write: if isSiteAdmin();
    }

    // 2. Collection group match for members (for queries)
    match /{path=**}/members/{memberId} {
      allow read: if isSignedIn();
    }

    // 3. Groups
    match /groups/{groupId} {
      allow read: if isSignedIn();

      // Enforce ownership on creation to prevent privilege escalation.
      allow create: if isSignedIn() &&
        request.resource.data.ownerId == request.auth.uid &&
        request.resource.data.get('memberCount', 0) == 1;

      allow update: if isSignedIn() && (
        resource.data.ownerId == request.auth.uid ||
        isSiteAdmin() ||
        request.resource.data.diff(resource.data).affectedKeys().hasOnly(['memberCount'])
      );

      allow delete: if isSignedIn() && (resource.data.ownerId == request.auth.uid || isSiteAdmin());

      match /events/{eventId} {
        allow read: if isSignedIn() && (
          isGroupAdmin(groupId) || 
          exists(/databases/$(database)/documents/groups/$(groupId)/members/$(request.auth.uid)) ||
          exists(/databases/$(database)/documents/groups/$(groupId)/joinRequests/$(request.auth.uid))
        );
        
        // Only Group Admins can create or delete events
        allow create, delete: if isGroupAdmin(groupId);
        
        // Update: Admins can update anything. Members can ONLY update RSVP fields or submit their MVP vote with validation.
        allow update: if isSignedIn() && (
          isGroupAdmin(groupId) || (
            exists(/databases/$(database)/documents/groups/$(groupId)/members/$(request.auth.uid)) &&
            request.resource.data.diff(resource.data).affectedKeys().hasOnly(['attendees', 'currentAttendees']) &&
            request.resource.data.attendees is list &&
            request.resource.data.currentAttendees is int &&
            request.resource.data.currentAttendees >= 0 &&
            (!('maxAttendees' in resource.data) || request.resource.data.currentAttendees <= resource.data.maxAttendees) &&
            (!('groupId' in request.resource.data) || request.resource.data.groupId == groupId)
          ) || (
            exists(/databases/$(database)/documents/groups/$(groupId)/members/$(request.auth.uid)) &&
            request.resource.data.diff(resource.data).affectedKeys().hasOnly(['mvpVotes']) &&
            request.resource.data.get('mvpVotes', {}) is map &&
            resource.data.get('mvpVotes', {}) is map &&
            // Voter can only add their own vote once
            request.resource.data.get('mvpVotes', {}).keys().hasAny([request.auth.uid]) &&
            !resource.data.get('mvpVotes', {}).keys().hasAny([request.auth.uid]) &&
            resource.data.mvpVotingEnabled == true &&
            resource.data.status == 'finished' &&
            (!('mvpVotingEndsAt' in resource.data) || request.time < resource.data.mvpVotingEndsAt) &&
            (request.resource.data.get('mvpVotes', {})[request.auth.uid] is string) &&
            resource.data.attendees.hasAny([request.auth.uid]) &&
            resource.data.attendees.hasAny([request.resource.data.get('mvpVotes', {})[request.auth.uid]]) &&
            request.auth.uid != request.resource.data.get('mvpVotes', {})[request.auth.uid]
          )
        );
      }

      match /members/{memberId} {
        allow read: if isSignedIn();
        
        // Joining or Owner Setup:
        allow create: if isSignedIn() && (
          // Case 1: Self-setup or Self-join
          (
            request.auth.uid == memberId && 
            request.resource.data.userId == request.auth.uid &&
            (
              // 1a: The Group Owner can set themselves as Admin (e.g. initial setup batch)
              // Note: group must exist first; avoids existsAfter/getAfter race condition.
              (isGroupOwner(groupId) &&
               request.resource.data.get('isAdmin', false) == true) ||
              // 1b: Regular user joining must be restricted (Only for Open groups)
              (
                request.resource.data.get('isAdmin', false) == false &&
                request.resource.data.get('role', 'user') == 'user' &&
                exists(/databases/$(database)/documents/groups/$(groupId)) &&
                (resource.data.type == 'open' || get(/databases/$(database)/documents/groups/$(groupId)).data.type == 'open')
              ) ||
              // 1c: Invited user can join closed groups
              (
                request.resource.data.get('isAdmin', false) == false &&
                request.resource.data.get('role', 'user') == 'user' &&
                hasPendingInvite(groupId, request.auth.uid)
              )
            )
          ) ||
          // Case 2: Group Admin adding someone or approving a request
          (
            isGroupAdmin(groupId) &&
            request.resource.data.userId == memberId &&
            request.resource.data.get('role', 'user') in ['user', 'admin', 'CsapatkapitÃ¡ny']
          )
        );
        
        // Updating: Group Admin can change anything (role, isAdmin). 
        // User can change their own data but NOT their role/isAdmin.
        allow update: if isSignedIn() && (
          isGroupAdmin(groupId) ||
          (request.auth.uid == memberId && !request.resource.data.diff(resource.data).affectedKeys().hasAny(['role', 'isAdmin']))
        );
        
        // Leaving or Removing: User can delete own doc, Admin can delete any
        allow delete: if isSignedIn() && (request.auth.uid == memberId || isGroupAdmin(groupId));
      }

      match /joinRequests/{requestId} {
        // Read: Only the requester or group admins can see the request
        allow read: if isSignedIn() && (request.auth.uid == requestId || isGroupAdmin(groupId));
        
        // Create: Only the user can create their own join request, ensuring identity
        allow create: if isSignedIn() && request.auth.uid == requestId && 
                      request.resource.data.userId == request.auth.uid;
        
        // Update: Only group admins can update the request (e.g., status change)
        allow update: if isGroupAdmin(groupId);
        
        // Delete: Requester can cancel their own, or group admin can reject/remove it
        allow delete: if isSignedIn() && (request.auth.uid == requestId || isGroupAdmin(groupId));
      }

      match /invites/{inviteId} {
        allow read: if isSignedIn() && (request.auth.uid == inviteId || isGroupAdmin(groupId));

        allow create: if isGroupAdmin(groupId) &&
          request.resource.data.get('groupId', '') == groupId &&
          request.resource.data.get('targetUserId', '') == inviteId &&
          request.resource.data.get('inviterId', '') == request.auth.uid &&
          request.resource.data.get('status', '') == 'pending';

        allow update: if isSignedIn() && (
          isGroupAdmin(groupId) ||
          (
            request.auth.uid == inviteId &&
            resource.data.get('status', '') == 'pending' &&
            request.resource.data.get('status', '') in ['accepted', 'declined'] &&
            request.resource.data.diff(resource.data).affectedKeys()
              .hasOnly(['status', 'respondedAt', 'legalAccepted', 'legalAcceptedAt'])
          )
        );

        allow delete: if isGroupAdmin(groupId);
      }

      // Lightweight audit logging (client-side) for free tier
      match /auditLogs/{logId} {
        allow read: if isGroupAdmin(groupId) || isSiteAdmin();
        allow create: if isSignedIn() &&
          request.resource.data.get('groupId', '') == groupId &&
          request.resource.data.get('actorId', '') == request.auth.uid &&
          request.resource.data.get('action', '') is string &&
          request.resource.data.get('createdAt', null) is timestamp;
      }
    }
  }
}
